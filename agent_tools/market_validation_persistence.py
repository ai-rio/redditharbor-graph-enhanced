#!/usr/bin/env python3
"""
Market Validation Persistence Module

This module handles the persistence of market validation evidence generated by
the MarketDataValidator into the RedditHarbor database.

It provides a clean interface to:
- Store ValidationEvidence objects to both storage tiers
- Retrieve market validation data for analysis
- Handle database errors and rollback scenarios
- Maintain data consistency between app_opportunities and market_validations
- Support the dual-tier storage strategy (quick access + detailed)

Database Schema:
- app_opportunities: Quick access columns for common queries
- market_validations: Detailed JSON storage with full evidence

Created: 2025-11-16
Author: RedditHarbor Data Engineering Team
"""

import json
import logging
from datetime import UTC, datetime
from typing import Any

from agent_tools.market_data_validator import ValidationEvidence
from config import settings
from supabase import create_client

logger = logging.getLogger(__name__)


class MarketValidationPersistence:
    """
    Handles persistence of market validation evidence to the database.

    Implements dual-tier storage:
    1. app_opportunities table: Quick access columns for common queries
    2. market_validations table: Full JSON storage with detailed evidence
    """

    def __init__(self, supabase_url: str | None = None, supabase_key: str | None = None):
        """
        Initialize the persistence handler.

        Args:
            supabase_url: Supabase URL (from settings if not provided)
            supabase_key: Supabase service role key (from settings if not provided)
        """
        self.supabase_url = supabase_url or settings.SUPABASE_URL
        self.supabase_key = supabase_key or settings.SUPABASE_KEY

        if not self.supabase_url or not self.supabase_key:
            raise ValueError("Supabase URL and key are required")

        self.client = create_client(self.supabase_url, self.supabase_key)

        logger.info("MarketValidationPersistence initialized")

    def save_validation_evidence(
        self,
        app_opportunity_id: str,
        opportunity_id: str | None = None,
        evidence: ValidationEvidence | None = None,
        validation_type: str = "jina_reader_market_validation",
        validation_source: str = "jina_api",
        custom_reasoning: str | None = None,
        custom_score: float | None = None,
    ) -> tuple[bool, str]:
        """
        Save market validation evidence to the database.

        Implements dual-tier storage:
        1. Updates app_opportunities with quick access columns
        2. Inserts detailed record in market_validations table

        Args:
            app_opportunity_id: UUID from app_opportunities table
            opportunity_id: UUID from opportunities table (optional)
            evidence: ValidationEvidence object with all validation data
            validation_type: Type of validation (jina_reader, manual, etc.)
            validation_source: Source of validation (jina_api, manual_review, etc.)
            custom_reasoning: Override reasoning if evidence is None
            custom_score: Override score if evidence is None

        Returns:
            Tuple of (success: bool, message: str)
        """
        try:
            # Validate inputs
            if not app_opportunity_id:
                return False, "app_opportunity_id is required"

            if not evidence and not (custom_reasoning or custom_score is not None):
                return False, "Either evidence or custom reasoning/score must be provided"

            # Get current timestamp
            validation_timestamp = datetime.now(UTC)

            # Extract data from evidence or use custom values
            if evidence:
                validation_score = evidence.validation_score
                data_quality_score = evidence.data_quality_score
                reasoning = evidence.reasoning
                competitors_found = self._serialize_competitors(evidence.competitor_pricing)
                market_size_tam = evidence.market_size.tam_value if evidence.market_size else None
                market_size_sam = evidence.market_size.sam_value if evidence.market_size else None
                market_size_growth = evidence.market_size.growth_rate if evidence.market_size else None
                similar_launches = len(evidence.similar_launches)
                total_cost = evidence.total_cost
                search_queries = evidence.search_queries_used
                urls_fetched = evidence.urls_fetched
                extraction_stats = self._prepare_extraction_stats(evidence)
            else:
                validation_score = custom_score or 0.0
                data_quality_score = 50.0  # Default when no evidence
                reasoning = custom_reasoning or "Custom validation score"
                competitors_found = []
                market_size_tam = None
                market_size_sam = None
                market_size_growth = None
                similar_launches = 0
                total_cost = 0.0
                search_queries = []
                urls_fetched = []
                extraction_stats = {}

            # Step 1: Update app_opportunities table (quick access columns)
            app_opportunities_data = {
                "market_validation_score": validation_score,
                "market_data_quality_score": data_quality_score,
                "market_validation_reasoning": reasoning,
                "market_competitors_found": competitors_found,
                "market_size_tam": market_size_tam,
                "market_size_sam": market_size_sam,
                "market_size_growth": market_size_growth,
                "market_similar_launches": similar_launches,
                "market_validation_cost_usd": total_cost,
                "market_validation_timestamp": validation_timestamp.isoformat(),
            }

            # Only update if we have meaningful data
            if validation_score > 0 or evidence:
                app_response = self.client.table("app_opportunities").update(
                    app_opportunities_data
                ).eq("id", app_opportunity_id)

                if app_response.data is None:
                    logger.error(f"Failed to update app_opportunities: {app_response}")
                    return False, f"Failed to update app_opportunities: {app_response}"

                logger.info(f"Updated app_opportunities {app_opportunity_id} with validation score {validation_score}")

            # Step 2: Insert detailed record in market_validations table
            market_validation_data = {
                "opportunity_id": opportunity_id or app_opportunity_id,  # Fallback to app_opportunity_id
                "validation_type": validation_type,
                "validation_source": validation_source,
                "validation_date": validation_timestamp.isoformat(),
                "validation_result": json.dumps(self._serialize_validation_result(evidence), indent=2),
                "confidence_score": min(1.0, data_quality_score / 100.0),  # Convert to 0-1 scale
                "notes": reasoning,
                "status": "completed",
                "evidence_url": self._extract_evidence_urls(evidence),
                # Jina-specific columns
                "market_validation_score": validation_score,
                "market_data_quality_score": data_quality_score,
                "market_validation_reasoning": reasoning,
                "market_competitors_found": competitors_found,
                "market_size_tam": market_size_tam,
                "market_size_sam": market_size_sam,
                "market_size_growth": market_size_growth,
                "market_similar_launches": similar_launches,
                "market_validation_cost_usd": total_cost,
                "search_queries_used": search_queries,
                "urls_fetched": urls_fetched,
                "extraction_stats": extraction_stats,
                "jina_api_calls_count": self._count_jina_calls(evidence),
                "jina_cache_hit_rate": self._calculate_cache_hit_rate(evidence),
            }

            validation_response = self.client.table("market_validations").insert(
                market_validation_data
            ).execute()

            if not hasattr(validation_response, 'data') or len(validation_response.data) == 0:
                logger.error(f"Failed to insert market_validation: {validation_response}")
                return False, f"Failed to insert market_validation: {validation_response}"

            validation_id = validation_response.data[0]["id"]
            logger.info(f"Created market_validation {validation_id} for opportunity {app_opportunity_id}")

            return True, f"Successfully saved validation evidence with ID: {validation_id}"

        except Exception as e:
            logger.error(f"Error saving validation evidence: {e}")
            return False, f"Database error: {e!s}"

    def get_market_validation(self, app_opportunity_id: str) -> dict[str, Any] | None:
        """
        Retrieve market validation data for an opportunity.

        Args:
            app_opportunity_id: UUID from app_opportunities table

        Returns:
            Dictionary with validation data or None if not found
        """
        try:
            # Get quick access data from app_opportunities
            app_response = self.client.table("app_opportunities").select(
                """
                id,
                problem_description,
                app_concept,
                target_user,
                opportunity_score,
                market_validation_score,
                market_data_quality_score,
                market_validation_reasoning,
                market_competitors_found,
                market_size_tam,
                market_size_sam,
                market_size_growth,
                market_similar_launches,
                market_validation_cost_usd,
                market_validation_timestamp
                """
            ).eq("id", app_opportunity_id).single()

            if not app_response.data:
                return None

            # Get detailed validation records
            validation_response = self.client.table("market_validations").select(
                """
                id,
                validation_type,
                validation_source,
                validation_date,
                confidence_score,
                search_queries_used,
                urls_fetched,
                extraction_stats,
                jina_api_calls_count,
                jina_cache_hit_rate
                """
            ).eq("opportunity_id", app_opportunity_id).order("validation_date", desc=True).limit(1)

            # Combine data
            result = app_response.data
            if validation_response.data:
                result.update(validation_response.data[0])

            return result

        except Exception as e:
            logger.error(f"Error retrieving market validation: {e}")
            return None

    def get_validation_analytics(self, limit: int = 100, min_score: float = 0) -> list[dict[str, Any]]:
        """
        Get market validation analytics for business intelligence.

        Args:
            limit: Maximum number of records to return
            min_score: Minimum validation score to include

        Returns:
            List of analytics records
        """
        try:
            response = self.client.table("market_validation_analytics").select("*").gte(
                "market_validation_score", min_score
            ).order("market_validation_timestamp", desc=True).limit(limit)

            return response.data or []

        except Exception as e:
            logger.error(f"Error retrieving validation analytics: {e}")
            return []

    def update_validation_status(
        self, validation_id: str, status: str, notes: str | None = None
    ) -> tuple[bool, str]:
        """
        Update the status of a market validation record.

        Args:
            validation_id: UUID from market_validations table
            status: New status ('pending', 'completed', 'failed')
            notes: Optional notes about the status update

        Returns:
            Tuple of (success: bool, message: str)
        """
        try:
            update_data = {"status": status}
            if notes:
                update_data["notes"] = notes

            response = self.client.table("market_validations").update(update_data).eq(
                "id", validation_id
            )

            if response.data is None:
                return False, f"Failed to update validation status: {response}"

            logger.info(f"Updated validation {validation_id} status to {status}")
            return True, f"Successfully updated status to {status}"

        except Exception as e:
            logger.error(f"Error updating validation status: {e}")
            return False, f"Database error: {e!s}"

    # Private helper methods

    def _serialize_competitors(self, competitors: list) -> list[dict]:
        """Serialize competitor data for JSON storage"""
        if not competitors:
            return []

        serialized = []
        for comp in competitors:
            serialized.append({
                "company_name": comp.company_name,
                "pricing_model": comp.pricing_model,
                "target_market": comp.target_market,
                "source_url": comp.source_url,
                "confidence": comp.confidence,
                "pricing_tiers": comp.pricing_tiers,
                "extracted_at": comp.extracted_at.isoformat() if comp.extracted_at else None,
            })
        return serialized

    def _serialize_validation_result(self, evidence: ValidationEvidence | None) -> dict:
        """Serialize the complete validation result for storage"""
        if not evidence:
            return {"message": "No validation evidence provided"}

        return {
            "validation_score": evidence.validation_score,
            "data_quality_score": evidence.data_quality_score,
            "reasoning": evidence.reasoning,
            "timestamp": evidence.timestamp.isoformat(),
            "total_cost": evidence.total_cost,
            "competitor_count": len(evidence.competitor_pricing),
            "similar_launches_count": len(evidence.similar_launches),
            "has_market_size": evidence.market_size is not None,
            "has_benchmarks": bool(evidence.industry_benchmarks),
            "search_queries_count": len(evidence.search_queries_used),
            "urls_fetched_count": len(evidence.urls_fetched),
        }

    def _extract_evidence_urls(self, evidence: ValidationEvidence | None) -> str:
        """Extract evidence URLs from validation data"""
        if not evidence:
            return ""

        urls = []

        # Competitor URLs
        for comp in evidence.competitor_pricing:
            urls.append(comp.source_url)

        # Market size source URL
        if evidence.market_size and evidence.market_size.source_url:
            urls.append(evidence.market_size.source_url)

        # Similar launch URLs
        for launch in evidence.similar_launches:
            if launch.source_url:
                urls.append(launch.source_url)

        return ", ".join(urls)

    def _prepare_extraction_stats(self, evidence: ValidationEvidence | None) -> dict:
        """Prepare extraction statistics for storage"""
        if not evidence:
            return {}

        # Get stats from the jina client if available
        stats = {
            "competitors_analyzed": len(evidence.competitor_pricing),
            "similar_launches_found": len(evidence.similar_launches),
            "search_queries_used": len(evidence.search_queries_used),
            "urls_fetched": len(evidence.urls_fetched),
            "validation_score": evidence.validation_score,
            "data_quality_score": evidence.data_quality_score,
            "total_cost": evidence.total_cost,
        }

        # Add market size extraction info
        if evidence.market_size:
            stats["market_size_found"] = True
            stats["market_size_confidence"] = evidence.market_size.confidence
            if evidence.market_size.tam_value:
                stats["market_size_tam"] = evidence.market_size.tam_value
            if evidence.market_size.growth_rate:
                stats["market_size_growth"] = evidence.market_size.growth_rate
        else:
            stats["market_size_found"] = False

        return stats

    def _count_jina_calls(self, evidence: ValidationEvidence | None) -> int:
        """Count total Jina API calls from evidence"""
        if not evidence:
            return 0

        # Estimate based on URLs fetched + search queries
        return len(evidence.urls_fetched) + len(evidence.search_queries_used)

    def _calculate_cache_hit_rate(self, evidence: ValidationEvidence | None) -> float:
        """Calculate cache hit rate estimate (placeholder for now)"""
        if not evidence:
            return 0.0

        # This would need to be tracked at the Jina client level
        # For now, return an estimate based on total calls
        total_calls = self._count_jina_calls(evidence)
        if total_calls == 0:
            return 0.0

        # Assume 30% cache hit rate as placeholder
        return 0.3

    def delete_old_validations(self, days_old: int = 90) -> tuple[int, str]:
        """
        Delete old market validation records to manage storage.

        Args:
            days_old: Delete records older than this many days

        Returns:
            Tuple of (deleted_count: int, message: str)
        """
        try:
            cutoff_date = datetime.now(UTC).replace(tzinfo=None)
            cutoff_date = cutoff_date.replace(day=cutoff_date.day - days_old)

            # Delete from market_validations table
            response = self.client.table("market_validations").delete().lt(
                "validation_date", cutoff_date.isoformat()
            )

            deleted_count = len(response.data or [])
            logger.info(f"Deleted {deleted_count} old validation records")

            return deleted_count, f"Successfully deleted {deleted_count} old validation records"

        except Exception as e:
            logger.error(f"Error deleting old validations: {e}")
            return 0, f"Error deleting old validations: {e!s}"


# ============================================================================
# CONVENIENCE FUNCTIONS
# ============================================================================

def get_persistence_handler() -> MarketValidationPersistence:
    """Get a configured persistence handler instance"""
    return MarketValidationPersistence()

def save_market_validation(
    app_opportunity_id: str,
    evidence: ValidationEvidence,
    opportunity_id: str | None = None,
) -> bool:
    """
    Convenience function to save market validation evidence.

    Args:
        app_opportunity_id: UUID from app_opportunities table
        evidence: ValidationEvidence object with validation data
        opportunity_id: Optional UUID from opportunities table

    Returns:
        True if successful, False otherwise
    """
    persistence = get_persistence_handler()
    success, message = persistence.save_validation_evidence(
        app_opportunity_id=app_opportunity_id,
        opportunity_id=opportunity_id,
        evidence=evidence,
    )
    if not success:
        logger.error(f"Failed to save market validation: {message}")
    return success

def get_market_validation_data(app_opportunity_id: str) -> dict[str, Any] | None:
    """
    Convenience function to retrieve market validation data.

    Args:
        app_opportunity_id: UUID from app_opportunities table

    Returns:
        Dictionary with validation data or None if not found
    """
    persistence = get_persistence_handler()
    return persistence.get_market_validation(app_opportunity_id)
